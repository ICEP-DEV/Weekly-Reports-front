import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { createAnimation, getTimeGivenProgression } from '@ionic/core';
import * as i0 from "@angular/core";
import * as ɵngcc0 from '@angular/core';
var AnimationController = /** @class */ (function () {
    function AnimationController() {
    }
    /**
     * Create a new animation
     */
    AnimationController.prototype.create = function (animationId) {
        return createAnimation(animationId);
    };
    /**
     * EXPERIMENTAL
     *
     * Given a progression and a cubic bezier function,
     * this utility returns the time value(s) at which the
     * cubic bezier reaches the given time progression.
     *
     * If the cubic bezier never reaches the progression
     * the result will be an empty array.
     *
     * This is most useful for switching between easing curves
     * when doing a gesture animation (i.e. going from linear easing
     * during a drag, to another easing when `progressEnd` is called)
     */
    AnimationController.prototype.easingTime = function (p0, p1, p2, p3, progression) {
        return getTimeGivenProgression(p0, p1, p2, p3, progression);
    };
    AnimationController.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function AnimationController_Factory() { return new AnimationController(); }, token: AnimationController, providedIn: "root" });
AnimationController.ɵfac = function AnimationController_Factory(t) { return new (t || AnimationController)(); };
AnimationController.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AnimationController, factory: function (t) { return AnimationController.ɵfac(t); }, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AnimationController, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
    return AnimationController;
}());
export { AnimationController };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5pbWF0aW9uLWNvbnRyb2xsZXIuanMiLCJzb3VyY2VzIjpbIkBpb25pYy9hbmd1bGFyL3Byb3ZpZGVycy9hbmltYXRpb24tY29udHJvbGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQWEsZUFBZSxFQUFFLHVCQUF1QixFQUFFLE1BQU0sYUFBYSxDQUFDO0FBRWxGOztBQUdBO0FBRWUsSUFGZjtBQUFrQyxLQXlCakM7QUFDQSxJQXpCQztBQUNEO0FBQ0csT0FBQztBQUNKLElBQUMsb0NBQU0sR0FBTixVQUFPLFdBQW9CO0FBQUssUUFDOUIsT0FBTyxlQUFlLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDdkMsSUFBQyxDQUFDO0FBRUYsSUFBQztBQUNEO0FBQ0c7QUFDRztBQUNHO0FBQ0c7QUFFRjtBQUFRO0FBQ0c7QUFFRjtBQUFRO0FBQ0c7QUFDRztBQUVILE9BRDFCO0FBQ0osSUFBQyx3Q0FBVSxHQUFWLFVBQVcsRUFBWSxFQUFFLEVBQVksRUFBRSxFQUFZLEVBQUUsRUFBWSxFQUFFLFdBQW1CO0FBQUssUUFDekYsT0FBTyx1QkFBdUIsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDL0QsSUFBQyxDQUFDO0FBRUg7S0ExQmEsbUJBQW1CLGlDQUgvQixVQUFVLENBQUMsZUFDVixVQUFVLEVBQUUsTUFBTTtBQUNuQixDQUFDLFNBQ1csbUJBQW1CLENBeUIvQjs7Ozs7O2dEQUNEO0FBQUUsOEJBaENGO0FBQUcsQ0ErQkYsQUF6QkQsSUF5QkM7O0FBL0JBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUtBLEFBQUEsQUF5QkEsQUF4QkEsQUFFQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFFQSxBQWFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBeEJBLEFBQUEsQUFIQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBeUJBLEFBL0JBLEFBK0JBLEFBekJBLEFBeUJBLEFBekJBLEFBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBbmltYXRpb24sIGNyZWF0ZUFuaW1hdGlvbiwgZ2V0VGltZUdpdmVuUHJvZ3Jlc3Npb24gfSBmcm9tICdAaW9uaWMvY29yZSc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBBbmltYXRpb25Db250cm9sbGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBhbmltYXRpb25cbiAgICovXG4gIGNyZWF0ZShhbmltYXRpb25JZD86IHN0cmluZyk6IEFuaW1hdGlvbiB7XG4gICAgcmV0dXJuIGNyZWF0ZUFuaW1hdGlvbihhbmltYXRpb25JZCk7XG4gIH1cblxuICAvKipcbiAgICogRVhQRVJJTUVOVEFMXG4gICAqXG4gICAqIEdpdmVuIGEgcHJvZ3Jlc3Npb24gYW5kIGEgY3ViaWMgYmV6aWVyIGZ1bmN0aW9uLFxuICAgKiB0aGlzIHV0aWxpdHkgcmV0dXJucyB0aGUgdGltZSB2YWx1ZShzKSBhdCB3aGljaCB0aGVcbiAgICogY3ViaWMgYmV6aWVyIHJlYWNoZXMgdGhlIGdpdmVuIHRpbWUgcHJvZ3Jlc3Npb24uXG4gICAqXG4gICAqIElmIHRoZSBjdWJpYyBiZXppZXIgbmV2ZXIgcmVhY2hlcyB0aGUgcHJvZ3Jlc3Npb25cbiAgICogdGhlIHJlc3VsdCB3aWxsIGJlIGFuIGVtcHR5IGFycmF5LlxuICAgKlxuICAgKiBUaGlzIGlzIG1vc3QgdXNlZnVsIGZvciBzd2l0Y2hpbmcgYmV0d2VlbiBlYXNpbmcgY3VydmVzXG4gICAqIHdoZW4gZG9pbmcgYSBnZXN0dXJlIGFuaW1hdGlvbiAoaS5lLiBnb2luZyBmcm9tIGxpbmVhciBlYXNpbmdcbiAgICogZHVyaW5nIGEgZHJhZywgdG8gYW5vdGhlciBlYXNpbmcgd2hlbiBgcHJvZ3Jlc3NFbmRgIGlzIGNhbGxlZClcbiAgICovXG4gIGVhc2luZ1RpbWUocDA6IG51bWJlcltdLCBwMTogbnVtYmVyW10sIHAyOiBudW1iZXJbXSwgcDM6IG51bWJlcltdLCBwcm9ncmVzc2lvbjogbnVtYmVyKTogbnVtYmVyW10ge1xuICAgIHJldHVybiBnZXRUaW1lR2l2ZW5Qcm9ncmVzc2lvbihwMCwgcDEsIHAyLCBwMywgcHJvZ3Jlc3Npb24pO1xuICB9XG59XG4iXX0=